/*
	合并两个排序的链表
	输入两个递增排序的链表，合并这两个链表并使新链表中的点仍然是按照递增排序的。链表结点定义为：
	struct LsitNode
	{
		int			m_nValue;
		ListNode* 	m_pNext;
	};
	1->3->5->7
	2->4->6->8
	容易犯的错误是 在写代码之前没有对合并的过程想清楚 最终合并出来的链表要么从中间断开了要么没有对合并的过程想清楚，最终合并出来的链表要么中间断开要么并没有做到递增排序。二是代码在鲁棒性方面存在问题，程序一旦有特殊的输入就会崩溃。
	合并两个链表首先从两个链表的头结点开始，链表1的头结点的值小于链表2头结点的值，因此链表1的头结点将是合并后链表的头结点。
	所以继续合并链表中剩余的结点，在两个链表中剩下的结点依然是排序的，因此合并这两个链表的步骤和前面的步骤是一样的。我们还是比较两个头结点的值，此时链表2的头结点的值小于链表1头结点的值，因此链表2的头结点的值将是合并剩余结点得到的链表的头结点。我们把这个结点和前面合并链表时得到的链表的尾结点链接起来。
	所以综上可以发现 就是一系列的递归过程，可以用递归函数来解决
	每当代码试图访问空指针指向的内存程序时程序就会奔溃，从而导致程序鲁棒性问题。在本题时一旦输入空的链表就会引入空的指针，因此我们要对空链表单独处理。当第一个链表时空链表，也就是它所指向的头结点时一个空指针时，那么把它和第二个链表合并，显然合并的结果就是第二个链表。同样，当输入的第二个链表的头结点时空指针的时候，我们把它和第一个链表合并得到的结果就是第一个链表。如果两个链表都是空链表，合并的结果是得到一个空链表。
	代码如下：
*/

ListNode* Merge(ListNode* pHead1,ListNode* pHead2)
{
	if(pHead1 == NULL)
		return pHead2;
	else if(pHead2 == NULL)
		return pHead1;
	
	ListNode* pMergedpHead = NULL;
	if(pHead1->m_nValue < pHead2->m_nValue)
	{
		pMergedpHead = pHead1;
		pMergedpHead->m_pNext = Merge(pHead1->m_pNext,pHead2);
	}
	else
	{
		pMergedpHead = pHead2;
		pMergedpHead->m_pNext = Merge(pHead1,pHead2->m_pNext);
	}
	return pMergedpHead;
}
