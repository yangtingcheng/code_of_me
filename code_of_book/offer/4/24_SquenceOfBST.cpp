/*
	二叉搜索树的后序遍历序列
	题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数组的任意两个数字都互不相同。
	例如输入数组{5，7，6，9，11，10，8}，则返回true，因为这个整数序列是下图的二叉搜索树的后序遍历结果。
		8
	6		10
  5   7    9   11
  在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树的结点的值，他们都比根结点的值小；第二部分都是右子树结点的值，他们都比根结点的值大。
  以数组{5，7，6，9，11，10，8}，后序遍历结果的最后一个数字8就是跟=根结点的值。在这个数组中，前3个数字5、7和6都比8小，是值为8的结点的左子树结点；后三个数字9、11和10都比8大，是值为8的结点的右子树结点。
  我们接下来用同样的方法确定与数组每一部分对应的子树的结构。这其实就是一个递归的过程。对于序列5、7、6，最后一个数字6是左子树的根结点的值。数字5比6小，是值为6的结点的左子节点，而7则是它的右子节点。同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比1小，是值为10的结点的左子结点，而11则是它的右子节点。
  我们再来分析另一个数组{7，4，6，5}.后序遍历的最后一个数是根结点，因此根结点的值是5.由于第一个数字7大于5，因此在对应的二叉搜索树中，根结点上是没有左子树的，数字7、4和6都是右子树结点的值。但我们发现在右子树中有一个结点的值为4，比根结点的值5小，这违背了二叉搜索树的定义。因此不存在一个二叉搜索树，它的后序遍历的结果是7、4、6、5.

*/


bool VerifySquenceOfBST(int sequence[],int length)
{
	if(sequence == NULL && length <= 0)
		return false;
	
	int root = sequence[i-1];	//根结点
	
	//在二叉搜索树中左子树的结点小于根结点的值
	int i = 0;
	for(; i < length - 1; ++i)
	{
		if(sequence[i] > root)
			break;
	}

	//在二叉搜索树中右子女结点大于根结点
	int j = i;
	for(; j < length-1; ++j)
	{
		if(sequence[j] < root)
			return false;
	}
	//判断左子树是否满足
	bool left = true;
	if(i > 0)
		left = VerifySquenceOfBST(sequence,i);		//递归
	//判断右子树是否满足
	bool right = true;
	if(i < length - 1)
		right = VerifySquenceOfBST(sequence+i,length-i-1);	//递归
}
