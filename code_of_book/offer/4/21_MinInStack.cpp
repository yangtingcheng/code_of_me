/*
	定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min,push及pop的时间复杂度都是O(1)。
	分析发现，可以把每次的最小元素（之前的最小元素和新压入栈的元素两者的较低值）都保存起来到另外一个辅助栈里面。举例论证。
	首先往空的数据栈亚茹数字3，显然现在3是最小值，我们也把这个最小值压入辅助栈，接下来往数据栈中压入数字4.由于4大于之前的最小值，因此我们任然往辅助栈里压入数字数字3.第三步继续往数据栈中压入数字2.由于2小于之前的数字3，因此我们把最小值更新为2，并把2压入辅助栈，同样压入数字1时，也要更新最小值，并把新的最小值压入辅助栈。
				数据栈		辅助栈		最小值
压入3			3			3			3
压入4			3,4			3,3			3
压入2			3,4,2		3,3,2		2
压入1			3,4,2,1		3,3,2,1		1
在辅助栈的栈顶元素始终都是最低元素,当最小元素从数据栈内被弹出之后，同时弹出辅助栈的栈顶元素，此时辅助栈的新栈顶元素就是下一个最小值。
*/

//m_data是数据栈，m_min是最小栈

template<class T>
void StackWithMin<T>::push(const T& value)			//push函数
{
	m_data.push(value);

	if(m_min.size() == 0 || value < m_min.top())	//新元素是最小值，插入到最小栈中
		m_min.push(value);
	else
		m_min.push(m_min.top());					//新元素不是最小值，插入最小栈的栈顶元素
}

template<class T>
void StackWithMin<T>::pop()							//pop()函数
{
	assert(m_data.size() > 0 && m_min.size() > 0);	//
	
	m_data.pop();
	m_min.pop();
}

template<class T>
const T& StackWithMin<T>::Min() const				//Min()函数
{
	assert(m_data.size() > 0 && m_min.size() > 0);

	return m_min.top();								//返回最小栈的栈顶元素
}


/*
	不管是广度优先遍历一个有向图还是一棵树，都要用到队列。第一步我们把起始结点（对树而言是根结点）放入到队列中。接下来每一次从队列的头部取出一个结点，遍历这个结点之后把从它能到达的结点（对树而言是子结点）都依次放入队列。我们重复这个遍历过程，知道这个队列中的结点全部被遍历为止。
*/
